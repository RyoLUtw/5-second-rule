<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>5 Second Rule Trainer</title>
  <style>
    :root {
      --bg: #f7f7fb;
      --card: #ffffff;
      --primary: #5a67d8;
      --primary-dark: #434190;
      --accent: #48bb78;
      --danger: #e53e3e;
      --text: #2d3748;
      --muted: #718096;
      --border: #e2e8f0;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    header {
      background: #fff;
      border-bottom: 1px solid var(--border);
      padding: 12px 16px;
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }
    .tab-btn {
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #f8fafc;
      cursor: pointer;
      transition: background 0.2s, color 0.2s, border 0.2s;
    }
    .tab-btn.active {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
    }
    .container {
      max-width: 1100px;
      margin: 16px auto 32px;
      padding: 0 12px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      margin-bottom: 16px;
    }
    h1, h2, h3, h4 {
      margin: 0 0 8px;
      color: var(--text);
    }
    p { margin: 4px 0 8px; color: var(--muted); }
    label { font-weight: 600; }
    input[type="text"], select, textarea {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      margin: 4px 0 8px;
      font-size: 14px;
    }
    textarea { min-height: 160px; }
    button {
      padding: 10px 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.1s, box-shadow 0.1s, background 0.2s;
    }
    button:active { transform: translateY(1px); }
    .btn-primary { background: var(--primary); color: #fff; }
    .btn-primary:hover { background: var(--primary-dark); }
    .btn-ghost { background: #f8fafc; color: var(--text); border: 1px solid var(--border); }
    .btn-danger { background: #fff5f5; color: var(--danger); border: 1px solid #fed7d7; }
    .btn-accent { background: var(--accent); color: #fff; }
    .flex { display: flex; align-items: center; gap: 8px; }
    .flex-wrap { flex-wrap: wrap; }
    .between { justify-content: space-between; }
    .grid { display: grid; gap: 12px; }
    .set-card { border: 1px solid var(--border); border-radius: 12px; padding: 12px; background: #fff; }
    .set-header { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: space-between; }
    .item-row { border: 1px dashed var(--border); padding: 10px; border-radius: 10px; margin: 8px 0; background: #fdfdfd; }
    .small { color: var(--muted); font-size: 13px; }
    .hidden { display: none !important; }
    .pill { padding: 4px 8px; border-radius: 999px; background: #edf2f7; color: var(--muted); font-size: 12px; }
    .mode-toggle button { border: 1px solid var(--border); background: #f8fafc; }
    .mode-toggle button.active { background: var(--primary); color: #fff; border-color: var(--primary); }
    .timer {
      font-size: 48px;
      text-align: center;
      margin: 12px 0;
      color: var(--primary-dark);
      font-weight: 700;
    }
    .score { font-size: 24px; font-weight: 700; }
    .progress {
      background: #e2e8f0;
      border-radius: 10px;
      height: 12px;
      overflow: hidden;
    }
    .progress-inner {
      background: var(--primary);
      width: 100%;
      height: 100%;
      transition: width 0.1s linear;
    }
    .state-block { text-align: center; }
    .selection-group { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
    .selection-group button { min-width: 80px; }
    .selection-group button.active { box-shadow: 0 0 0 2px rgba(74, 85, 104, 0.2); transform: translateY(-1px); }
    .disabled { opacity: 0.6; pointer-events: none; }
    .hearts { font-size: 26px; }
    .tag { background: #f1f5f9; padding: 4px 8px; border-radius: 8px; margin: 0 4px; font-size: 12px; display: inline-block; }
    .panel { background: #f8fafc; border: 1px solid var(--border); border-radius: 10px; padding: 12px; }
    .status-tags { display: flex; gap: 8px; flex-wrap: wrap; }
    .status-tags .tag { min-width: 140px; text-align: center; }
    .status-metrics { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 12px; }
    .status-metric { background: #f8fafc; border: 1px solid var(--border); border-radius: 10px; padding: 12px; flex: 1 1 50vw; max-width: min(50vw, 440px); max-height: 140px; }
    .status-value { font-size: 26px; font-weight: 700; }
    .point-change { min-height: 18px; font-size: 18px; color: var(--accent); }
    .point-change.negative { color: var(--danger); }
    .target-control { display: flex; align-items: center; gap: 8px; flex-direction: column; }
    .target-control input[type="range"] { width: 100%; }
    .target-control .btn-ghost { min-width: 40px; }
    .target-count-display { font-size: 32px; font-weight: 800; text-align: center; }
    .target-count-controls { display: flex; align-items: center; gap: 8px; width: 100%; justify-content: center; }
    .stepper { display: inline-flex; align-items: center; gap: 8px; }
    .stepper .value { min-width: 28px; text-align: center; font-weight: 700; }
    .control-row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .modal-backdrop.hidden { display: none !important; pointer-events: none; }
    .modal { background: #fff; border-radius: 12px; padding: 16px; width: min(640px, 94vw); box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .report-list { list-style: none; padding: 0; margin: 0; display: grid; gap: 8px; }
    .report-item { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #f9fafb; }
    @media (max-width: 720px) {
      header { position: sticky; top: 0; }
      .set-header { flex-direction: column; align-items: flex-start; }
      button, input, select { width: 100%; }
      .selection-group { flex-direction: column; align-items: stretch; }
      .mode-toggle { width: 100%; }
      .mode-toggle button { flex: 1; }
    }
  </style>
</head>
<body>
  <header>
    <button class="tab-btn active" id="tab-manage">Study Sets</button>
    <button class="tab-btn" id="tab-game">Game</button>
    <div class="pill">Single HTML â€¢ No backend</div>
  </header>

  <div class="container">
    <section id="manage-page" class="card">
      <div class="flex between flex-wrap">
        <div>
          <h2>Study Set Management</h2>
          <p>Build vocabulary practice sets, import from JSON, or back them up.</p>
        </div>
      </div>

      <div class="card" id="drive-card">
        <h3>Back Up</h3>
        <p class="small">Save a copy to Google Drive with the built-in connection or keep it in this browser.</p>
        <div class="small">You will stay signed in on this device after connecting.</div>
        <div class="flex flex-wrap">
          <button class="btn-ghost" id="btn-drive-connect">Connect to Google Drive</button>
          <button class="btn-ghost" id="btn-drive-signout">Sign out</button>
          <button class="btn-primary" id="btn-drive-save">Save sets to Google Drive</button>
          <button class="btn-ghost" id="btn-save-local">Save sets in browser</button>
        </div>
        <div class="small" id="drive-msg"></div>
      </div>

      <div class="flex flex-wrap" style="gap:8px; margin-bottom:12px;">
        <button class="btn-primary" id="btn-new-set">New Set</button>
        <button class="btn-ghost" id="btn-import">Import JSON</button>
      </div>

      <div id="sets-list" class="grid"></div>
    </section>

    <section id="game-page" class="card hidden">
      <div class="flex between flex-wrap">
        <div>
          <h2>Game</h2>
          <p>Pick a study set, difficulty, and mode, then start a run.</p>
        </div>
      </div>

      <div class="card" id="setup-card">
        <div class="flex between flex-wrap">
          <div>
            <h3>Game Setup</h3>
            <p class="small">Active study set, difficulty, and game mode.</p>
          </div>
          <button class="btn-ghost" id="toggle-setup">Collapse</button>
        </div>
        <div id="setup-body" class="grid" style="grid-template-columns: repeat(auto-fit,minmax(260px,1fr)); margin-top:8px;">
          <div class="panel">
            <h4>Game Mode</h4>
            <div class="flex flex-wrap mode-toggle">
              <button id="mode-survival" class="tab-btn">Survival</button>
              <button id="mode-endless" class="tab-btn">Endless Streak</button>
            </div>
          </div>
          <div class="panel">
            <label for="set-select">Active Study Set</label>
            <select id="set-select"></select>
            <div class="small" id="set-hint"></div>
          </div>
          <div class="panel">
            <h4>Difficulty</h4>
            <div class="selection-group" id="difficulty-group">
              <label><input type="radio" name="difficulty" value="easy"> Easy</label>
              <label><input type="radio" name="difficulty" value="medium" checked> Medium</label>
              <label><input type="radio" name="difficulty" value="hard"> Hard</label>
            </div>
            <div class="small">Base points per correct answer: Easy 1 Â· Medium 2 Â· Hard 3.</div>
          </div>
          <div class="panel">
            <h4>Timer & Lives</h4>
            <div class="control-row">
              <div class="stepper">
                <button class="btn-ghost" id="timer-decrease">-</button>
                <span class="value" id="timer-value">5s</span>
                <button class="btn-ghost" id="timer-increase">+</button>
              </div>
              <span class="small">Timer length</span>
            </div>
            <div class="control-row" id="lives-row">
              <div class="stepper">
                <button class="btn-ghost" id="lives-decrease">-</button>
                <span class="value" id="lives-value">3</span>
                <button class="btn-ghost" id="lives-increase">+</button>
              </div>
              <span class="small">Starting lives (Survival)</span>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <h4>Best Records</h4>
        <div id="best-survival" class="small">Survival best score: 0</div>
        <div id="best-endless" class="small">Endless best streak: 0 Â· Best score: 0</div>
      </div>

      <div class="card hidden" id="status-card">
        <div class="status-tags">
          <div class="tag" id="status-mode"></div>
          <div class="tag" id="status-difficulty"></div>
        </div>
        <div class="status-metrics">
          <div class="status-metric">
            <div class="small">Lives</div>
            <div class="status-value hearts" id="lives-display"></div>
            <div class="point-change" id="life-change"></div>
          </div>
          <div class="status-metric">
            <div class="small">Total Points</div>
            <div class="status-value score" id="status-score">0</div>
            <div class="point-change" id="score-change"></div>
          </div>
        </div>
      </div>


      <div class="card" id="game-area">
        <div id="state-idle" class="state-block">
          <p>Select mode, difficulty, and study set to begin.</p>
          <div class="selection-group" style="margin-top:12px;">
            <button class="btn-primary" id="btn-start">Start Game</button>
          </div>
        </div>

        <div id="state-preview" class="hidden">
          <h4 class="small">Upcoming prompt</h4>
          <h3 id="preview-text">Prompt preview</h3>
          <div class="selection-group" style="margin-top:12px;">
            <button class="btn-primary" id="btn-start-timer">Start Timer</button>
          </div>
        </div>

        <div id="state-prompt" class="hidden">
          <h3 id="prompt-text">Prompt goes here</h3>
          <div class="timer" id="timer">5</div>
          <div class="progress"><div class="progress-inner" id="progress-inner"></div></div>
          <div class="selection-group" style="margin-top:12px;">
            <button class="btn-primary" id="btn-pause">Pause</button>
          </div>
        </div>

        <div id="state-eval" class="hidden">
          <h3 id="eval-prompt"></h3>
          <div class="panel" style="text-align:left;">
            <div id="eval-answers"></div>
            <p class="small" id="eval-answer-note"></p>
          </div>
          <h4>How did it go?</h4>
          <div class="selection-group" id="performance-group">
            <button data-perf="nailed" class="btn-primary">Nailed it (3 answers)</button>
            <button data-perf="almost" class="btn-ghost">Almost (2 answers)</button>
            <button data-perf="freeze" class="btn-danger">Brain freeze (0 answers)</button>
          </div>
          <h4>Target vocabulary used?</h4>
          <div class="target-control">
            <div class="target-count-display" id="target-count-display">0</div>
            <div class="target-count-controls">
              <button class="btn-ghost" id="target-decrease">-</button>
              <input type="range" min="0" max="7" value="0" id="target-slider">
              <button class="btn-ghost" id="target-increase">+</button>
            </div>
            <div class="small" id="target-count-label">Target vocabulary: 0</div>
          </div>
          <div id="score-breakdown" class="card" style="margin-top:12px; text-align:left;"></div>
          <div class="selection-group" style="margin-top:12px;">
            <button class="btn-accent" id="btn-confirm" disabled>Confirm</button>
            <button class="btn-danger" id="btn-end">End Run</button>
          </div>
        </div>

        <div id="state-over" class="hidden"></div>
      </div>
    </section>
  </div>

  <!-- Import Modal -->
  <div id="import-modal" class="modal-backdrop hidden">
    <div class="modal">
      <h3>Import Study Sets from JSON</h3>
      <p class="small">Paste an array of study sets with <code>name</code> and <code>items</code> (each item has <code>prompt</code>, <code>targetWords</code>, <code>answers</code>, and <code>distractors</code> arrays).</p>
      <textarea id="import-text" placeholder='[{"name":"My Set","items":[{"prompt":"Name 3...","targetWords":["a","b"],"answers":["answer 1","answer 2"],"distractors":["d1","d2"]}]}]'></textarea>
      <div class="small" id="import-error" style="color:var(--danger); min-height: 18px;"></div>
      <div class="flex between">
        <button class="btn-primary" id="btn-import-confirm">Import</button>
        <button class="btn-ghost" id="btn-import-cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Run Summary Modal -->
  <div id="summary-modal" class="modal-backdrop hidden">
    <div class="modal">
      <h3>Run Summary</h3>
      <div class="small" id="summary-meta"></div>
      <ul class="report-list" id="summary-rounds"></ul>
      <div class="small" id="summary-totals" style="margin-top:8px;"></div>
      <div class="selection-group" style="margin-top:12px;">
        <button class="btn-primary" id="btn-play-again">Play again (same mode)</button>
        <button class="btn-ghost" id="btn-back">Back to Game Menu</button>
      </div>
    </div>
  </div>

  <script>
    // ---------------------------
    // Storage helpers and defaults
    // ---------------------------
    const STORAGE_KEYS = {
      sets: 'fiveSecondStudySets',
      bestSurvival: 'fiveSecondBestScoreSurvival',
      bestEndlessScore: 'fiveSecondBestScoreEndless',
      bestEndlessStreak: 'fiveSecondBestStreakEndless',
      lastSet: 'fiveSecondLastStudySetName',
      lastDifficulty: 'fiveSecondLastDifficulty',
      driveSession: 'fiveSecondDriveSession'
    };
    const DEFAULT_CLIENT_ID = '332987792434-u7r3hdl46asbqo0si3ngqu46kdbgf2at.apps.googleusercontent.com';
    const DRIVE_SCOPE = 'https://www.googleapis.com/auth/drive.file';
    const TOKEN_MARGIN_MS = 60 * 1000; // refresh slightly before expiration
    const DRIVE_AUTOSAVE_DELAY_MS = 1500;
    let gsiLoaderPromise = null;
    let tokenClient = null;
    let accessToken = null;
    let tokenExpiresAt = 0;
    let driveAutosaveTimeout = null;
    let driveAutosaveInFlight = false;
    let driveAutosavePending = false;

    function restoreDriveSession() {
      const saved = localStorage.getItem(STORAGE_KEYS.driveSession);
      if (!saved) return false;
      try {
        const parsed = JSON.parse(saved);
        if (parsed.token && parsed.expiresAt && Date.now() < parsed.expiresAt) {
          accessToken = parsed.token;
          tokenExpiresAt = parsed.expiresAt;
          return true;
        }
      } catch (e) {
        console.warn('Failed to parse drive session', e);
      }
      return false;
    }

    function persistDriveSession() {
      if (!accessToken || !tokenExpiresAt) return;
      localStorage.setItem(STORAGE_KEYS.driveSession, JSON.stringify({ token: accessToken, expiresAt: tokenExpiresAt }));
    }

    function clearDriveSession() {
      localStorage.removeItem(STORAGE_KEYS.driveSession);
    }

    async function signOutDrive() {
      const msg = document.getElementById('drive-msg');
      msg.textContent = 'Signing out of Google Drive...';
      try {
        const tokenToRevoke = accessToken;
        accessToken = null;
        tokenExpiresAt = 0;
        clearDriveSession();
        await loadGsiScript();
        if (tokenToRevoke && window.google?.accounts?.oauth2?.revoke) {
          await new Promise((resolve, reject) => {
            window.google.accounts.oauth2.revoke(tokenToRevoke, ({ successful }) => {
              if (successful) resolve();
              else reject(new Error('Token revocation failed.'));
            });
          });
        }
        msg.textContent = 'Signed out of Google Drive for this app.';
      } catch (err) {
        console.error(err);
        msg.textContent = 'Signed out locally. Unable to revoke Drive session: ' + err.message;
      }
    }

    async function uploadStudySetsToDrive(token) {
      const fileContent = JSON.stringify({ studySets }, null, 2);
      const file = new Blob([fileContent], { type: 'application/json' });
      const metadata = { name: 'five_second_study_sets.json', mimeType: 'application/json' };
      const form = new FormData();
      form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
      form.append('file', file);
      await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
        method: 'POST',
        headers: new Headers({ Authorization: 'Bearer ' + token }),
        body: form
      });
    }

    function scheduleDriveAutosave() {
      driveAutosavePending = true;
      const msg = document.getElementById('drive-msg');
      msg.textContent = 'Autosaving changes to Google Drive...';
      if (driveAutosaveTimeout) clearTimeout(driveAutosaveTimeout);
      driveAutosaveTimeout = setTimeout(runDriveAutosave, DRIVE_AUTOSAVE_DELAY_MS);
    }

    async function runDriveAutosave() {
      if (driveAutosaveInFlight) {
        driveAutosaveTimeout = setTimeout(runDriveAutosave, DRIVE_AUTOSAVE_DELAY_MS);
        return;
      }
      driveAutosavePending = false;
      driveAutosaveTimeout = null;
      driveAutosaveInFlight = true;
      const msg = document.getElementById('drive-msg');
      try {
        const token = await ensureDriveToken({ silent: true });
        if (!token) {
          msg.textContent = 'Connect to Google Drive to enable autosave.';
          return;
        }
        msg.textContent = 'Autosaving changes to Google Drive...';
        await uploadStudySetsToDrive(token);
        msg.textContent = 'Changes autosaved to Google Drive.';
        unsavedChanges = false;
      } catch (err) {
        console.error(err);
        msg.textContent = 'Drive autosave failed: ' + err.message;
      } finally {
        driveAutosaveInFlight = false;
        if (driveAutosavePending && !driveAutosaveTimeout) {
          driveAutosaveTimeout = setTimeout(runDriveAutosave, DRIVE_AUTOSAVE_DELAY_MS);
        }
      }
    }

    let studySets = [];
    let currentMode = null; // 'survival' | 'endless'
    let currentRun = null;   // Tracks the current session data
    let timerInterval = null;
    let timerStart = null;
    let timerEnd = null;
    let timerRemaining = 5000;
    let timerPaused = false;
    let timerLengthSeconds = 5;
    let startingLives = 3;
    const MIN_TIMER_SECONDS = 3;
    const MAX_TIMER_SECONDS = 30;
    const MIN_LIVES = 1;
    const MAX_LIVES = 10;
    const POINT_CHANGE_STEP_MS = 300;
    const DIFFICULTY_TIMERS = { easy: 8, medium: 5, hard: 4 };
    const POINTS_PER_LIFE = 5;
    let setupCollapsed = false;
    let lifeChangePending = 0;
    let scoreChangePending = 0;
    let changeInterval = null;

    function normalizeSetMeta() {
      studySets.forEach((set, idx) => {
        if (set._open === undefined) set._open = false;
        if (set._editing === undefined) set._editing = false;
        if (!Array.isArray(set.items)) set.items = [];
        set.items.forEach((item) => {
          if (!Array.isArray(item.targetWords)) item.targetWords = [];
          if (!Array.isArray(item.answers)) item.answers = [];
          if (!Array.isArray(item.distractors)) item.distractors = [];
        });
      });
    }

    function parseStudySetsPayload(payload) {
      if (Array.isArray(payload)) return payload;
      if (payload && Array.isArray(payload.studySets)) return payload.studySets;
      return null;
    }

    // Load study sets or use defaults
    function loadStudySets() {
      const saved = localStorage.getItem(STORAGE_KEYS.sets);
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          const sets = parseStudySetsPayload(parsed) || parsed;
          if (Array.isArray(sets)) {
            studySets = sets;
            normalizeSetMeta();
            return;
          }
        } catch (e) {
          console.warn('Failed to parse saved sets, starting empty', e);
        }
      }
      studySets = [];
      normalizeSetMeta();
    }

    function saveStudySets({ markClean = true } = {}) {
      localStorage.setItem(STORAGE_KEYS.sets, JSON.stringify(studySets));
      if (markClean) unsavedChanges = false;
    }

    function loadBestScores() {
      return {
        survival: Number(localStorage.getItem(STORAGE_KEYS.bestSurvival) || 0),
        endlessScore: Number(localStorage.getItem(STORAGE_KEYS.bestEndlessScore) || 0),
        endlessStreak: Number(localStorage.getItem(STORAGE_KEYS.bestEndlessStreak) || 0)
      };
    }

    function updateBestScores({ survival, endlessScore, endlessStreak }) {
      if (survival !== undefined) localStorage.setItem(STORAGE_KEYS.bestSurvival, String(survival));
      if (endlessScore !== undefined) localStorage.setItem(STORAGE_KEYS.bestEndlessScore, String(endlessScore));
      if (endlessStreak !== undefined) localStorage.setItem(STORAGE_KEYS.bestEndlessStreak, String(endlessStreak));
      renderBestStats();
    }

    function getLastStudySetName() { return localStorage.getItem(STORAGE_KEYS.lastSet); }
    function setLastStudySetName(name) { localStorage.setItem(STORAGE_KEYS.lastSet, name); }

    function getLastDifficulty() { return localStorage.getItem(STORAGE_KEYS.lastDifficulty); }
    function setLastDifficulty(diff) { localStorage.setItem(STORAGE_KEYS.lastDifficulty, diff); }

    // ---------------------------
    // Rendering helpers
    // ---------------------------
    function renderStudySets() {
      const list = document.getElementById('sets-list');
      list.innerHTML = '';
      if (!studySets.length) {
        list.innerHTML = '<p>No sets yet. Create a new one or import JSON.</p>';
        return;
      }
      studySets.forEach((set, setIndex) => {
        if (set._open === undefined) set._open = false;
        if (set._editing === undefined) set._editing = false;
        const card = document.createElement('div');
        card.className = 'set-card';
        card.innerHTML = `
          <div class="set-header">
            <div class="flex" style="flex:1 1 auto; align-items:center; gap:8px;">
              <button class="btn-ghost toggle-open">${set._open ? 'Collapse' : 'Expand'}</button>
              <input type="text" value="${set.name}" aria-label="Set name" data-field="name" ${!set._editing ? 'disabled' : ''} />
            </div>
            <span class="small">${set.items.length} items</span>
            <div class="flex" style="gap:8px;">
              <button class="btn-ghost edit-btn">${set._editing ? 'Done' : 'Edit'}</button>
              <button class="btn-danger">Delete set</button>
            </div>
          </div>
          <div class="set-body" style="display:${set._open ? 'block' : 'none'};"></div>
          ${set._editing ? '<button class="btn-ghost add-item-btn">Add item</button>' : ''}
        `;

        const nameInput = card.querySelector('input[data-field="name"]');
        nameInput.addEventListener('input', (e) => {
          set.name = e.target.value || 'Untitled set';
          renderSetSelect();
          markStudySetsChanged();
        });

        const toggleBtn = card.querySelector('.toggle-open');
        toggleBtn.addEventListener('click', () => {
          const newState = !set._open;
          studySets.forEach((s, i) => {
            if (i !== setIndex) {
              s._open = false;
              s._editing = false;
            }
          });
          set._open = newState;
          if (!set._open) set._editing = false;
          renderStudySets();
        });

        const editBtn = card.querySelector('.edit-btn');
        editBtn.addEventListener('click', () => {
          studySets.forEach((s, i) => {
            if (i !== setIndex) {
              s._open = false;
              s._editing = false;
            }
          });
          set._open = true;
          set._editing = !set._editing;
          renderStudySets();
          renderSetSelect();
        });

        const deleteBtn = card.querySelector('.btn-danger');
        deleteBtn.addEventListener('click', () => {
          if (confirm('Delete this set?')) {
            studySets.splice(setIndex, 1);
            renderStudySets();
            renderSetSelect();
            markStudySetsChanged();
          }
        });

        const body = card.querySelector('.set-body');
        set.items.forEach((item, itemIndex) => {
          body.appendChild(renderItemRow(set, item, itemIndex, !set._editing));
        });

        const addBtn = card.querySelector('.add-item-btn');
        if (addBtn) {
          addBtn.addEventListener('click', () => {
            const newItem = { prompt: '', targetWords: [], answers: [], distractors: [] };
            set.items.push(newItem);
            set._open = true;
            set._editing = true;
            body.appendChild(renderItemRow(set, newItem, set.items.length - 1));
            renderSetSelect();
            markStudySetsChanged();
          });
        }

        list.appendChild(card);
      });
    }

    function renderItemRow(set, item, itemIndex, readOnly = false) {
      const row = document.createElement('div');
      row.className = 'item-row';
      row.innerHTML = `
        <label>Prompt</label>
        <input type="text" value="${item.prompt}" placeholder="Name 3..." ${readOnly ? 'disabled' : ''} />
        <label>Target words (comma separated)</label>
        <input type="text" value="${item.targetWords.join(', ')}" placeholder="tropical, juicy, citrus" ${readOnly ? 'disabled' : ''} />
        <label>Sample answers (comma separated)</label>
        <input type="text" value="${item.answers.join(', ')}" placeholder="apple, orange, banana" ${readOnly ? 'disabled' : ''} />
        <label>Distractors (comma separated)</label>
        <input type="text" value="${item.distractors.join(', ')}" placeholder="word that does not fit" ${readOnly ? 'disabled' : ''} />
        ${readOnly ? '' : '<button class="btn-danger delete-item-btn">Delete item</button>'}
      `;
      const [promptInput, targetInput, answersInput, distractorsInput] = row.querySelectorAll('input');
      if (!readOnly) {
        promptInput.addEventListener('input', (e) => { item.prompt = e.target.value; markStudySetsChanged(); });
        targetInput.addEventListener('input', (e) => {
          item.targetWords = e.target.value.split(',').map(w => w.trim()).filter(Boolean);
          markStudySetsChanged();
        });
        answersInput.addEventListener('input', (e) => {
          item.answers = e.target.value.split(',').map(w => w.trim()).filter(Boolean);
          markStudySetsChanged();
        });
        distractorsInput.addEventListener('input', (e) => {
          item.distractors = e.target.value.split(',').map(w => w.trim()).filter(Boolean);
          markStudySetsChanged();
        });
        const del = row.querySelector('.delete-item-btn');
        del.addEventListener('click', () => {
          set.items.splice(itemIndex, 1);
          renderStudySets();
          renderSetSelect();
          markStudySetsChanged();
        });
      }
      return row;
    }

    function renderSetSelect() {
      const select = document.getElementById('set-select');
      const hint = document.getElementById('set-hint');
      select.innerHTML = '';
      if (!studySets.length) {
        select.disabled = true;
        hint.textContent = 'No study sets available. Create or import one first.';
        return;
      }
      select.disabled = false;
      studySets.forEach((set) => {
        const opt = document.createElement('option');
        opt.value = set.name;
        opt.textContent = `${set.name} (${set.items.length} items)`;
        select.appendChild(opt);
      });
      const last = getLastStudySetName();
      if (last && studySets.some(s => s.name === last)) {
        select.value = last;
      }
      hint.textContent = 'Selected set will be used for prompts.';
    }

    function ensureGameSelection() {
      const select = document.getElementById('set-select');
      if (!select.options.length) return;
      const last = getLastStudySetName();
      if (last && Array.from(select.options).some(opt => opt.value === last)) {
        select.value = last;
        return;
      }
      if (!Array.from(select.options).some(opt => opt.value === select.value)) {
        select.selectedIndex = 0;
        setLastStudySetName(select.value);
      }
    }

    function toggleSetupContainer(forceState) {
      if (typeof forceState === 'boolean') {
        setupCollapsed = forceState;
      } else {
        setupCollapsed = !setupCollapsed;
      }
      const body = document.getElementById('setup-body');
      body.classList.toggle('hidden', setupCollapsed);
      document.getElementById('toggle-setup').textContent = setupCollapsed ? 'Expand' : 'Collapse';
    }

    function updateStatus() {
      const statusCard = document.getElementById('status-card');
      statusCard.classList.toggle('hidden', !currentRun);
      if (!currentRun) return;
      const modeLabel = currentMode === 'survival' ? 'Survival' : currentMode === 'endless' ? 'Endless Streak' : 'Mode not selected';
      document.getElementById('status-mode').textContent = modeLabel;
      document.getElementById('status-difficulty').textContent = `Difficulty: ${currentRun.difficulty}`;
      document.getElementById('status-score').textContent = Math.round(currentRun.score * 10) / 10;
      const lifeChangeEl = document.getElementById('life-change');
      const scoreChangeEl = document.getElementById('score-change');
      lifeChangeEl.textContent = lifeChangePending ? `${lifeChangePending > 0 ? '+' : ''}${lifeChangePending}` : '';
      lifeChangeEl.classList.toggle('negative', lifeChangePending < 0);
      scoreChangeEl.textContent = scoreChangePending ? `${scoreChangePending > 0 ? '+' : ''}${scoreChangePending}` : '';
      scoreChangeEl.classList.toggle('negative', scoreChangePending < 0);
      if (currentRun.mode === 'survival') {
        document.getElementById('lives-display').textContent = renderHearts(currentRun.lives);
      } else {
        document.getElementById('lives-display').textContent = 'âˆž';
        lifeChangeEl.textContent = '';
      }
    }

    function animatePointChanges(lifeDelta = 0, scoreDelta = 0, onDone) {
      lifeChangePending = Number((lifeChangePending + lifeDelta).toFixed(2));
      scoreChangePending = Number((scoreChangePending + scoreDelta).toFixed(2));
      updateStatus();
      if (lifeChangePending === 0 && scoreChangePending === 0) {
        if (typeof onDone === 'function') onDone();
        return;
      }
      if (changeInterval) return;
      changeInterval = setInterval(() => {
        let progressed = false;
        if (currentRun) {
          if (lifeChangePending !== 0) {
            const lifeStep = Math.abs(lifeChangePending) >= 1 ? 1 : Math.abs(lifeChangePending);
            const apply = Math.sign(lifeChangePending) * lifeStep;
            currentRun.lives = Math.max(0, currentRun.lives + apply);
            lifeChangePending = Number((lifeChangePending - apply).toFixed(2));
            progressed = true;
          }
          if (scoreChangePending !== 0) {
            const scoreStep = Math.abs(scoreChangePending) >= 1 ? 1 : Math.abs(scoreChangePending);
            const applyScore = Math.sign(scoreChangePending) * scoreStep;
            currentRun.score = Math.round((currentRun.score + applyScore) * 10) / 10;
            scoreChangePending = Number((scoreChangePending - applyScore).toFixed(2));
            progressed = true;
          }
          updateStatus();
        }
        if (!progressed || (lifeChangePending === 0 && scoreChangePending === 0)) {
          clearInterval(changeInterval);
          changeInterval = null;
          if (typeof onDone === 'function') onDone();
        }
      }, POINT_CHANGE_STEP_MS);
    }

    function renderBestStats() {
      const best = loadBestScores();
      document.getElementById('best-survival').textContent = `Survival best score: ${best.survival}`;
      document.getElementById('best-endless').textContent = `Endless best streak: ${best.endlessStreak} Â· Best score: ${best.endlessScore}`;
    }

    function hideSummaryModal() {
      document.getElementById('summary-modal').classList.add('hidden');
    }

    function showSummaryModal(data) {
      const modal = document.getElementById('summary-modal');
      const roundsList = document.getElementById('summary-rounds');
      const meta = document.getElementById('summary-meta');
      const totals = document.getElementById('summary-totals');
      meta.textContent = `Mode: ${data.mode === 'survival' ? 'Survival' : 'Endless Streak'} Â· Difficulty: ${data.difficulty} Â· Rounds: ${data.rounds}`;
      if (!data.roundLog.length) {
        roundsList.innerHTML = '<li class="report-item">No rounds recorded.</li>';
      } else {
        roundsList.innerHTML = data.roundLog.map((r, idx) => `
          <li class="report-item">
            <strong>Prompt ${idx + 1}:</strong> ${r.prompt}<br>
            Answers: ${r.answers} Â· Target words used: ${r.targetsUsed} Â· Points: ${r.points}
          </li>
        `).join('');
      }
      const lifeBonus = Math.max(0, data.lifeLeft) * POINTS_PER_LIFE;
      totals.innerHTML = `Base points: <strong>${data.score}</strong> Â· Lives left: ${data.lifeLeft}${data.mode === 'survival' ? ` (bonus ${lifeBonus})` : ''}<br>Total points with bonus: <strong>${Math.round((data.score + lifeBonus) * 10) / 10}</strong>`;
      modal.classList.remove('hidden');
    }

    // ---------------------------
    // Import / Export helpers
    // ---------------------------
    function downloadSets() {
      const blob = new Blob([JSON.stringify(studySets, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'study_sets.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    function validateImportedSets(data) {
      if (!Array.isArray(data)) return false;
      return data.every(set => set && typeof set.name === 'string' && Array.isArray(set.items) && set.items.every(item => item && typeof item.prompt === 'string' && Array.isArray(item.targetWords || []) && Array.isArray(item.answers || []) && Array.isArray(item.distractors || [])));
    }

    function replaceStudySets(newSets, { markClean = false, skipAutosave = false } = {}) {
      studySets = newSets;
      normalizeSetMeta();
      renderStudySets();
      renderSetSelect();
      saveStudySets({ markClean });
      unsavedChanges = !markClean;
      if (!markClean && !skipAutosave) scheduleDriveAutosave();
    }

    function appendStudySets(newSets) {
      const combined = [...studySets, ...newSets];
      replaceStudySets(combined);
    }

    function openImportModal() {
      document.getElementById('import-modal').classList.remove('hidden');
      document.getElementById('import-text').value = '';
      document.getElementById('import-error').textContent = '';
    }

    function closeImportModal() {
      document.getElementById('import-modal').classList.add('hidden');
    }

    function handleImport() {
      const text = document.getElementById('import-text').value;
      const error = document.getElementById('import-error');
      try {
        const parsed = JSON.parse(text);
        const candidate = parseStudySetsPayload(parsed) || parsed;
        if (!validateImportedSets(candidate)) {
          error.textContent = 'Invalid format. Ensure it is an array of sets with name, items, targetWords, answers, and distractors arrays.';
          return;
        }
        appendStudySets(candidate);
        closeImportModal();
      } catch (e) {
        error.textContent = 'JSON parse error: ' + e.message;
      }
    }

    // ---------------------------
    // Mode selection and tabs
    // ---------------------------
    function switchTab(target) {
      document.getElementById('manage-page').classList.toggle('hidden', target !== 'manage');
      document.getElementById('game-page').classList.toggle('hidden', target !== 'game');
      document.getElementById('tab-manage').classList.toggle('active', target === 'manage');
      document.getElementById('tab-game').classList.toggle('active', target === 'game');
      if (target === 'game') {
        renderSetSelect();
        ensureGameSelection();
      }
    }

    function setMode(mode) {
      currentMode = mode;
      document.getElementById('mode-survival').classList.toggle('active', mode === 'survival');
      document.getElementById('mode-endless').classList.toggle('active', mode === 'endless');
      updateLivesVisibility();
      updateStatus();
    }

    function updateTimerDisplay() {
      document.getElementById('timer-value').textContent = `${timerLengthSeconds}s`;
      document.getElementById('lives-value').textContent = startingLives;
    }

    function applyDifficultyTimerPreset(diff) {
      const preset = DIFFICULTY_TIMERS[diff];
      if (preset) {
        timerLengthSeconds = preset;
        updateTimerDisplay();
      }
    }

    function adjustTimer(delta) {
      timerLengthSeconds = Math.max(MIN_TIMER_SECONDS, Math.min(MAX_TIMER_SECONDS, timerLengthSeconds + delta));
      updateTimerDisplay();
    }

    function adjustLives(delta) {
      startingLives = Math.max(MIN_LIVES, Math.min(MAX_LIVES, startingLives + delta));
      updateTimerDisplay();
    }

    function updateLivesVisibility() {
      document.getElementById('lives-row').style.display = currentMode === 'survival' ? 'flex' : 'none';
    }

    // Track unsaved changes
    let unsavedChanges = false;

    function markStudySetsChanged() {
      unsavedChanges = true;
      scheduleDriveAutosave();
    }

    // ---------------------------
    // Game flow helpers
    // ---------------------------
    function getSelectedDifficulty() {
      const checked = document.querySelector('input[name="difficulty"]:checked');
      return checked ? checked.value : 'medium';
    }

    function difficultyMultiplier(diff) {
      return diff === 'easy' ? 1 : diff === 'hard' ? 3 : 2;
    }

    function performanceToCorrect(perf) {
      if (perf === 'nailed') return 3;
      if (perf === 'almost') return 2;
      return 0;
    }

    function renderHearts(lives) {
      const hearts = [];
      const full = Math.floor(lives);
      const hasHalf = lives % 1 >= 0.5;
      for (let i = 0; i < full; i++) hearts.push('â¤ï¸');
      if (hasHalf && hearts.length < 3) hearts.push('ðŸ’”');
      while (hearts.length < 3) hearts.push('ðŸ¤');
      return hearts.join('');
    }

    function startGame() {
      if (!currentMode) {
        alert('Please choose a mode first.');
        return;
      }
      if (!studySets.length) {
        alert('Please create or import a study set first.');
        return;
      }
      const setName = document.getElementById('set-select').value;
      const set = studySets.find(s => s.name === setName);
      if (!set || !set.items.length) {
        alert('Selected set has no items.');
        return;
      }
      const difficulty = getSelectedDifficulty();
      setLastDifficulty(difficulty);
      setLastStudySetName(setName);
      const timerDurationMs = timerLengthSeconds * 1000;
      currentRun = {
        mode: currentMode,
        setName,
        setItems: set.items,
        difficulty,
        lives: currentMode === 'survival' ? startingLives : null,
        score: 0,
        streak: 0,
        rounds: 0,
        lastIndex: -1,
        timerDuration: timerDurationMs,
        roundLog: []
      };
      lifeChangePending = 0;
      scoreChangePending = 0;
      if (changeInterval) { clearInterval(changeInterval); changeInterval = null; }
      timerRemaining = timerDurationMs;
      toggleSetupContainer(true);
      updateStatus();
      hideSummaryModal();
      goToPrompt();
    }

    function goToPrompt() {
      if (!currentRun) return;
      const { setItems, lastIndex } = currentRun;
      if (!setItems.length) return;
      let idx = Math.floor(Math.random() * setItems.length);
      if (setItems.length > 1 && idx === lastIndex) {
        idx = (idx + 1) % setItems.length;
      }
      currentRun.lastIndex = idx;
      const item = setItems[idx];
      document.getElementById('prompt-text').textContent = item.prompt || 'Unnamed prompt';
      document.getElementById('eval-prompt').textContent = item.prompt || 'Unnamed prompt';
      const answerList = Array.isArray(item.answers) ? item.answers : [];
      const targetWords = Array.isArray(item.targetWords) ? item.targetWords : [];
      const targetSet = new Set(targetWords.map(w => w.toLowerCase()));
      const answersText = answerList.length
        ? answerList.map(ans => targetSet.has(ans.toLowerCase()) ? `<strong>${ans}</strong>` : ans).join(', ')
        : (targetWords.length ? targetWords.map(word => `<strong>${word}</strong>`).join(', ') : 'No sample answers provided.');
      document.getElementById('eval-answers').innerHTML = `<strong>Sample answers:</strong> ${answersText}`;
      document.getElementById('eval-answer-note').textContent = 'Target words are shown in bold within the sample answers.';
      clearSelections();
      currentRun.currentItem = item;
      const duration = currentRun.timerDuration || (timerLengthSeconds * 1000);
      timerRemaining = duration;
      timerPaused = false;
      document.getElementById('btn-pause').textContent = 'Pause';
      document.getElementById('timer').textContent = Math.ceil(timerRemaining / 1000);
      document.getElementById('progress-inner').style.width = '100%';
      document.getElementById('preview-text').textContent = item.prompt || 'Unnamed prompt';
      switchState('preview');
    }

    function startPromptTimer() {
      if (!currentRun || document.getElementById('state-preview').classList.contains('hidden')) return;
      switchState('prompt');
      startTimer();
    }

    function switchState(state) {
      ['state-idle','state-preview','state-prompt','state-eval','state-over'].forEach(id => {
        document.getElementById(id).classList.toggle('hidden', id !== `state-${state}`);
      });
      if (state === 'prompt') updateStatus();
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerStart = performance.now();
      timerEnd = timerStart + timerRemaining;
      timerPaused = false;
      timerInterval = setInterval(updateTimer, 100);
      updateTimer();
    }

    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function updateTimer() {
      const now = performance.now();
      const remaining = Math.max(0, (timerEnd || now) - now);
      timerRemaining = remaining;
      const seconds = Math.ceil(remaining / 1000);
      document.getElementById('timer').textContent = seconds;
      const total = currentRun?.timerDuration || (timerLengthSeconds * 1000);
      const pct = (remaining / total) * 100;
      document.getElementById('progress-inner').style.width = pct + '%';
      if (remaining <= 0) {
        stopTimer();
        openEvaluation();
      }
    }

    function togglePause() {
      if (!currentRun || document.getElementById('state-prompt').classList.contains('hidden')) return;
      if (timerPaused) {
        timerPaused = false;
        startTimer();
        document.getElementById('btn-pause').textContent = 'Pause';
      } else {
        timerPaused = true;
        timerRemaining = Math.max(0, (timerEnd || performance.now()) - performance.now());
        stopTimer();
        document.getElementById('btn-pause').textContent = 'Resume';
        document.getElementById('timer').textContent = Math.ceil(timerRemaining / 1000);
        const total = currentRun?.timerDuration || (timerLengthSeconds * 1000);
        document.getElementById('progress-inner').style.width = (timerRemaining / total) * 100 + '%';
      }
    }

    function openEvaluation() {
      stopTimer();
      switchState('eval');
      updateStatus();
    }

    function clearSelections() {
      selectedPerformance = null;
      selectedTargetCount = 0;
      document.querySelectorAll('#performance-group button').forEach(btn => btn.classList.remove('active'));
      setTargetCount(0);
      document.getElementById('score-breakdown').innerHTML = '';
      document.getElementById('btn-confirm').disabled = true;
    }

    let selectedPerformance = null;
    let selectedTargetCount = 0;

    function selectPerformance(perf) {
      selectedPerformance = perf;
      document.querySelectorAll('#performance-group button').forEach(btn => btn.classList.toggle('active', btn.dataset.perf === perf));
      maybeShowBreakdown();
    }

    function setTargetCount(count) {
      selectedTargetCount = Math.max(0, Math.min(7, Number(count)));
      const slider = document.getElementById('target-slider');
      slider.value = selectedTargetCount;
      document.getElementById('target-count-display').textContent = selectedTargetCount;
      document.getElementById('target-count-label').textContent = `Target vocabulary: ${selectedTargetCount}`;
      maybeShowBreakdown();
    }

    function maybeShowBreakdown() {
      if (selectedPerformance === null || selectedTargetCount === null) return;
      const diff = currentRun.difficulty;
      const correct = performanceToCorrect(selectedPerformance);
      const basePoints = correct * difficultyMultiplier(diff);
      const multiplier = 1 + (selectedTargetCount * 0.5);
      const finalPoints = Math.round(basePoints * multiplier * 10) / 10;
      document.getElementById('score-breakdown').innerHTML = `
        <div><strong>Base points:</strong> ${basePoints}</div>
        <div><strong>Target words:</strong> ${selectedTargetCount}</div>
        <div><strong>Multiplier:</strong> ${multiplier.toFixed(1)}x</div>
        <div><strong>Points this round:</strong> ${finalPoints}</div>
      `;
      document.getElementById('btn-confirm').disabled = false;
      document.getElementById('btn-confirm').dataset.finalPoints = finalPoints;
    }

    function applyRound() {
      if (selectedPerformance === null || selectedTargetCount === null) return;
      const finalPoints = Number(document.getElementById('btn-confirm').dataset.finalPoints || 0);
      document.getElementById('btn-confirm').disabled = true;
      currentRun.rounds += 1;
      let lifeDelta = 0;
      if (currentRun.mode === 'survival') {
        if (selectedPerformance === 'almost') lifeDelta = -0.5;
        if (selectedPerformance === 'freeze') lifeDelta = -1;
      }
      if (currentRun.mode === 'endless' && selectedPerformance === 'nailed') {
        currentRun.streak += 1;
      }
      const answers = performanceToCorrect(selectedPerformance);
      const promptText = currentRun.currentItem?.prompt || 'Unnamed prompt';
      currentRun.roundLog.push({
        prompt: promptText,
        answers,
        targetsUsed: selectedTargetCount,
        points: finalPoints
      });
      document.getElementById('score-breakdown').innerHTML = '';
      const projectedLives = currentRun.mode === 'survival' ? currentRun.lives + lifeDelta : null;
      const survivalWillEnd = currentRun.mode === 'survival' && projectedLives <= 0;
      const endlessWillEnd = currentRun.mode === 'endless' && selectedPerformance !== 'nailed';
      const willContinue = !(survivalWillEnd || endlessWillEnd);
      if (willContinue) {
        document.getElementById('state-eval').classList.add('hidden');
        goToPrompt();
      }
      const proceedAfterAnimation = () => {
        if (!currentRun) return;
        if (!willContinue) {
          endRun();
        }
      };
      animatePointChanges(lifeDelta, finalPoints, proceedAfterAnimation);
    }

    function endRun() {
      stopTimer();
      if (changeInterval) {
        clearInterval(changeInterval);
        changeInterval = null;
      }
      if (!currentRun) return;
      const best = loadBestScores();
      if (currentRun.mode === 'survival') {
        if (currentRun.score > best.survival) {
          best.survival = currentRun.score;
        }
        updateBestScores({ survival: best.survival });
      } else {
        if (currentRun.score > best.endlessScore) best.endlessScore = currentRun.score;
        if (currentRun.streak > best.endlessStreak) best.endlessStreak = currentRun.streak;
        updateBestScores({ endlessScore: best.endlessScore, endlessStreak: best.endlessStreak });
      }
      const lifeLeft = currentRun.mode === 'survival' ? Math.max(0, Math.round(currentRun.lives * 2) / 2) : 0;
      const summaryData = {
        mode: currentRun.mode,
        difficulty: currentRun.difficulty,
        rounds: currentRun.rounds,
        score: Math.round(currentRun.score * 10) / 10,
        lifeLeft,
        roundLog: currentRun.roundLog || []
      };
      lifeChangePending = 0;
      scoreChangePending = 0;
      updateStatus();
      currentRun = null;
      switchState('idle');
      showSummaryModal(summaryData);
    }

    function backToMenu() {
      stopTimer();
      if (changeInterval) {
        clearInterval(changeInterval);
        changeInterval = null;
      }
      lifeChangePending = 0;
      scoreChangePending = 0;
      currentRun = null;
      switchState('idle');
      toggleSetupContainer(false);
      updateStatus();
      hideSummaryModal();
    }

    // ---------------------------
    // Google Drive saving (optional)
    // ---------------------------
    function loadGsiScript() {
      if (window.google && window.google.accounts && window.google.accounts.oauth2) return Promise.resolve();
      if (!gsiLoaderPromise) {
        gsiLoaderPromise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://accounts.google.com/gsi/client';
          script.async = true;
          script.defer = true;
          script.onload = () => resolve();
          script.onerror = () => reject(new Error('Failed to load Google Identity Services.'));
          document.head.appendChild(script);
        });
      }
      return gsiLoaderPromise;
    }

    async function ensureDriveToken({ promptConsent = false, silent = false } = {}) {
      restoreDriveSession();
      await loadGsiScript();
      if (!tokenClient) {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: DEFAULT_CLIENT_ID,
          scope: DRIVE_SCOPE,
          callback: () => {}
        });
      }
      const shouldRefresh = !accessToken || Date.now() + TOKEN_MARGIN_MS >= tokenExpiresAt;
      if (!shouldRefresh) return accessToken;

      return new Promise((resolve, reject) => {
        tokenClient.callback = (resp) => {
          if (resp.error) {
            clearDriveSession();
            reject(new Error(resp.error));
            return;
          }
          accessToken = resp.access_token;
          tokenExpiresAt = Date.now() + (resp.expires_in ? resp.expires_in * 1000 : 0);
          persistDriveSession();
          resolve(accessToken);
        };
        const promptMode = promptConsent ? 'consent' : silent ? 'none' : '';
        tokenClient.requestAccessToken({ prompt: promptMode });
      });
    }

    async function connectDrive() {
      const msg = document.getElementById('drive-msg');
      msg.textContent = 'Connecting to Google Drive...';
      try {
        await ensureDriveToken({ promptConsent: true });
        msg.textContent = 'Connected to Google Drive. Syncing your study sets...';
        await syncStudySetsFromDrive();
      } catch (err) {
        console.error(err);
        msg.textContent = 'Drive connect failed: ' + err.message;
      }
    }

    async function saveToDrive() {
      const msg = document.getElementById('drive-msg');
      try {
        const token = await ensureDriveToken({ silent: true });
        if (!token) {
          msg.textContent = 'Please connect to Google Drive before saving.';
          return;
        }
        msg.textContent = 'Uploading study sets to Google Drive...';
        await uploadStudySetsToDrive(token);
        msg.textContent = 'Saved to Google Drive!';
        unsavedChanges = false;
      } catch (err) {
        console.error(err);
        msg.textContent = 'Drive save failed: ' + err.message;
      }
    }

    async function fetchDriveStudySets(token) {
      const listResp = await fetch('https://www.googleapis.com/drive/v3/files?q=name%3D%27five_second_study_sets.json%27+and+trashed%3Dfalse&fields=files(id,modifiedTime,name)&orderBy=modifiedTime%20desc&pageSize=1', {
        headers: new Headers({ Authorization: 'Bearer ' + token })
      });
      if (!listResp.ok) throw new Error('Unable to list study set backups on Drive.');
      const listData = await listResp.json();
      if (!listData.files || !listData.files.length) return null;
      const fileId = listData.files[0].id;
      const fileResp = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
        headers: new Headers({ Authorization: 'Bearer ' + token })
      });
      if (!fileResp.ok) throw new Error('Unable to download study sets from Drive.');
      const content = await fileResp.text();
      const parsed = JSON.parse(content);
      const sets = parseStudySetsPayload(parsed) || parsed.studySets || parsed;
      if (!validateImportedSets(sets)) throw new Error('Drive file is not in the expected format.');
      return sets;
    }

    async function syncStudySetsFromDrive() {
      const msg = document.getElementById('drive-msg');
      msg.textContent = 'Syncing study sets from Google Drive...';
      try {
        const token = await ensureDriveToken({ silent: true });
        if (!token) {
          msg.textContent = 'Please connect to Google Drive before syncing.';
          return;
        }
        const remoteSets = await fetchDriveStudySets(token);
        if (remoteSets && remoteSets.length) {
          replaceStudySets(remoteSets, { markClean: true, skipAutosave: true });
          msg.textContent = 'Study sets synced from Google Drive.';
        } else {
          msg.textContent = 'No saved study sets found on Google Drive yet.';
        }
      } catch (err) {
        console.error(err);
        msg.textContent = 'Drive sync failed: ' + err.message;
      }
    }

    async function tryRestoreDriveConnection() {
      const msg = document.getElementById('drive-msg');
      if (restoreDriveSession()) {
        msg.textContent = 'Signed in to Google Drive. Session restored on this device.';
        await syncStudySetsFromDrive();
        return;
      }
      try {
        const token = await ensureDriveToken({ silent: true });
        if (token) {
          msg.textContent = 'Signed in to Google Drive. Session remembered on this device.';
          await syncStudySetsFromDrive();
        }
      } catch (e) {
        clearDriveSession();
      }
    }

    // ---------------------------
    // Event listeners and init
    // ---------------------------
    document.getElementById('tab-manage').addEventListener('click', () => switchTab('manage'));
    document.getElementById('tab-game').addEventListener('click', () => switchTab('game'));
    document.getElementById('btn-new-set').addEventListener('click', () => {
      const count = studySets.length + 1;
      studySets.push({ name: `New Set ${count}`, items: [], _open: true, _editing: true });
      studySets.forEach((s, i, arr) => {
        if (i !== arr.length - 1) { s._open = false; s._editing = false; }
      });
      studySets = [studySets.pop(), ...studySets]; // move new set to top
      renderStudySets();
      renderSetSelect();
      markStudySetsChanged();
      // Scroll to bottom to reveal new set
      document.getElementById('manage-page').scrollIntoView({ behavior: 'smooth', block: 'start' });
    });
    document.getElementById('btn-import').addEventListener('click', openImportModal);
    document.getElementById('btn-import-cancel').addEventListener('click', closeImportModal);
    document.getElementById('btn-import-confirm').addEventListener('click', handleImport);
    document.getElementById('btn-save-local').addEventListener('click', () => { saveStudySets(); alert('Saved locally.'); });
    document.getElementById('btn-drive-connect').addEventListener('click', connectDrive);
    document.getElementById('btn-drive-signout').addEventListener('click', signOutDrive);
    document.getElementById('btn-drive-save').addEventListener('click', saveToDrive);

    document.getElementById('set-select').addEventListener('change', (e) => setLastStudySetName(e.target.value));

    document.getElementById('difficulty-group').addEventListener('change', () => {
      const diff = getSelectedDifficulty();
      setLastDifficulty(diff);
      applyDifficultyTimerPreset(diff);
    });

    document.getElementById('mode-survival').addEventListener('click', () => setMode('survival'));
    document.getElementById('mode-endless').addEventListener('click', () => setMode('endless'));
    document.getElementById('btn-start').addEventListener('click', startGame);
    document.getElementById('btn-start-timer').addEventListener('click', startPromptTimer);
    document.getElementById('btn-pause').addEventListener('click', togglePause);
    document.getElementById('btn-end').addEventListener('click', endRun);
    document.getElementById('btn-confirm').addEventListener('click', applyRound);
    document.getElementById('btn-back').addEventListener('click', backToMenu);
    document.getElementById('btn-play-again').addEventListener('click', () => {
      const lastMode = currentRun ? currentRun.mode : currentMode;
      currentRun = null;
      setMode(lastMode);
      startGame();
    });

    document.getElementById('performance-group').addEventListener('click', (e) => {
      if (e.target.dataset.perf) selectPerformance(e.target.dataset.perf);
    });
    document.getElementById('target-slider').addEventListener('input', (e) => setTargetCount(e.target.value));
    document.getElementById('target-decrease').addEventListener('click', () => setTargetCount(selectedTargetCount - 1));
    document.getElementById('target-increase').addEventListener('click', () => setTargetCount(selectedTargetCount + 1));
    document.getElementById('timer-decrease').addEventListener('click', () => adjustTimer(-1));
    document.getElementById('timer-increase').addEventListener('click', () => adjustTimer(1));
    document.getElementById('lives-decrease').addEventListener('click', () => adjustLives(-1));
    document.getElementById('lives-increase').addEventListener('click', () => adjustLives(1));
    document.getElementById('toggle-setup').addEventListener('click', () => toggleSetupContainer());

    // Initialize app
    loadStudySets();
    renderStudySets();
    renderSetSelect();
    tryRestoreDriveConnection();
    ensureGameSelection();
    renderBestStats();
    const lastDiff = getLastDifficulty();
    if (lastDiff) {
      const radio = document.querySelector(`input[name="difficulty"][value="${lastDiff}"]`);
      if (radio) radio.checked = true;
    }
    applyDifficultyTimerPreset(getSelectedDifficulty());
    window.addEventListener('beforeunload', (e) => {
      if (unsavedChanges) {
        e.preventDefault();
        e.returnValue = '';
      }
    });
    setTargetCount(0);
    updateTimerDisplay();
    updateLivesVisibility();
    toggleSetupContainer(false);
    updateStatus();
  </script>
</body>
</html>
